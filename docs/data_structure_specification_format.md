This document describes the language-independent description of data structures, or UCLIDS (UConn Language Independent Description of Structures), that shall be used to generate the visualization of data structures.

# Goals

UCLIDS should be

1. easy to parse

2. easy to output during a traversal of the data structure

3. human readable

4. extensible (in the sense that it's easy to add more types of data structures)

UCLIDS should not:

1. specify how the algorithm is to be visualized

2. take more than polynomial space in the size of the data structure that it describes

# Proposal (incomplete)

For each instance of a data structure to be visualized, the visualization program needs to be told:

1. which instance it is

2. indication of the type of data structure (e.g. list, array, tree, graph, digraph)  (at least once per instance)

3. the actual structure of it, which depends on the data structure.

## Other considerations

1. If we do a good job, UCLIDS could be used sort of like tikz, i.e. read and written by humans.  (But unlike tikz, our language will not specify anything about the geometry of the image that gets drawn.)

2. We can make UCLIDS syntax flexible in sort of the way GDB syntax is flexible.  For instance, in GDB you can type "c", "cont", or "continue".  Code generated by machines should use the long form of every command so that the meaning of the output is obvious, but humans may, at their own peril, use short commands.

3. Idiomatic implementations of data structures in different lanuages need not result in the same description.  This applies especially to prominence of pointers in some languages.  For example, conceptually, a node of a tree can contain whatever data it wishes, even a pointer to its parent node (although our program may just choke on loops like that).

4. Aesthetically, I like some things about Tikz.

5. UCLIDS must be able to represent the same data structure at different times, e.g. at different stages of the structure's construction.  This will be difficult, because, for example, it will be difficult.  (TODO: write better when not 1 AM)

## Complexity creeping in from the edges

Consider the following scenario:

> List `A` contains list `B`, which contains list `A`.

I actually came up with a one-liner solution for the "complicated" problem I'm working my way up to here, so never mind it.